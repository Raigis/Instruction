# Инструкция по использованию [**Git**](#git)
## Введение
В этой инструкции мы попытаемся установить и разобраться в работе программы [**Git**](#git) на примере русифицированного **Visual Studio Code**.
> Если желаете повторять описываемое также в **Visual Studio Code**, скачать его можно на оффициальном сайте <https://code.visualstudio.com/>, либо напрямую [отсюда](https://code.visualstudio.com/docs/?dv=win64user)

> Руссифицировать **Visual Studio Code** можно вызвав комбинацией клавиш <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>P</kbd> окно ввода команд, где начать писать команду `Configure Display Language` до её появления в окне выбора комад, нажать на неё, и в открывшемся списке выбрать русский язык.
## Установка [**Git**](#git)
Установить [**Git**](#git) можно на на сайте <https://git-scm.com/>, или напрямую скачать установщик [отсюда](https://github.com/git-for-windows/git/releases/download/v2.42.0.windows.2/Git-2.42.0.2-64-bit.exe)

Во время установки оставляйте настройки по-умолчанию, кроме двух моментов:  
* На этом окне нужно выбрать редактор, к которому будет привязан [**Git**](#git)  
![Первая картинка](Картинки/Первый.png)
* На этом окне, если требуется, можно изменить название [ветки](#branch) по-умолчанию  
![Вторая картинка](Картинки/Второй.png)
## Начало работы
Для начала нам нужно в редакторе: 
* во-первых, проверить правильно ли установлен *(или установлен ли вообще)* [**Git**](#git). Для этого нужно открыть терминал.
    * Вариант 1. Нажать на кнопку в меню сверху справа ![Вариант 1](Картинки/ТермВариант1.png)
    * Вариант 2. Нажать на кнопку `Терминал` сверху слева, после чего нажать в появившемся окне `Создать терминал`  
    ![Вариант 2](Картинки/ТермВариант2.png)
    * Вариант 3. Комбинациями клавиш 
        * <kbd>CTRL</kbd>+<kbd>`</kbd>
        * <kbd>CTRL</kbd>+<kbd>SHIFT</kbd>+<kbd>`</kbd>
        * <kbd>CTRL</kbd>+<kbd>J</kbd>
        
    Далее, в открытом терминале нужно ввести команду `git --version`. Если [**Git**](#git) установлен правильно терминал выдаст следующий результат:  
![Терминал](Картинки/Терминал.png)
* во-вторых, открыть папку, в которой будет находиться наш репозиторий *(что это такое расскажем чуть позже)*  
    * Вариант 1. Нажать на кнопку `Открыть папку` в окне приветствия.  
![Первый вариант](Картинки/Вариант1.png)
    * Вариант 2. Нажать на кнопку `Открыть папку` в проводнике слева *(выглядит так: ![Проводник](Картинки/Проводник.png))*  
![Второй вариант](Картинки/Вариант2.png)
    * Вариант 3. В меню сверху слева нажать `Файл`, после чего в открывшемся окне нажать `Открыть папку`  
![Третий вариант](Картинки/Вариант3.png)
    * Вариант 4. Последовательный ввод комбинаций клавиш <kbd>CTRL</kbd>+<kbd>K</kbd> <kbd>CTRL</kbd>+<kbd>O</kbd>, которые можно увидеть при выполнении варианта 3
### <a id="terms">Термины</a>
Для работы с гитом желательно знать определения для некоторых терминов:
> <a id="git">**Git**</a> — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит).

> <a id="wd">Рабочая директория</a> — файловая система проекта (те файлы, с которыми вы работаете).

> <a id="rep">Репозиторий</a> - отслеживаемая **Git-ом** рабочая директория.

> <a id="index">Индекс</a> — список отслеживаемых **Git-ом** файлов и директорий, промежуточное хранилище изменений (редактирование, удаление отслеживаемых файлов).

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).  
Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые, изменённые, проиндексированные (готовые к коммиту).

> Директория <a id=".git">**.git**</a> — все данные контроля версий этого проекта (вся история разработки: коммиты, ветки, теги и пр.).

> <a id="commit">Коммит</a> — «сохранение» (хранит набор изменений, сделанный в рабочей директории с момента предыдущего коммита). Коммит неизменен, его нельзя отредактировать.

У всех коммитов (кроме самого первого) есть один или более родительских коммитов, поскольку коммиты хранят изменения от предыдущих состояний.
### Инициализация
После того, как мы проверили работоспособность **Git-a** и открыли нужную папку, нам необходимо инициализировать репозиторий в этой папке. Для этого в терминале необходимо ввести команду `git init`. Теперь [**Git**](#git) будет отслеживать всё происходящее в этой папке.
> Если сейчас мы зайдём в папку нашей рабочей директориии, то обнаружим появление в ней папки [**.git**](#.git), о назначении которой написано в разделе [терминов](#terms)
### Первый [коммит](#commit)
Теперь, когда мы удачно инициировали [**Git**](#git) в нашей папке пора создать в ней файл и провести первый [коммит](#commit).  
Создать файл можно, как напрямую в пвпке, так и с поиощью функционала **Visual Studio Code**:
* Вариант 1. В проводнике *(напоминаю, что он выглядит так ![Проводник](Картинки/Проводник.png))* навести курсор на название папки, после чего нажать на появившийся значок ![Значок](Картинки/Значок.png)
* Вариант 2. Через знакомую нам кнопку `Файл`, где, в открывшимся окне на этот раз нажать `Создать файл`  
![Вариант 2](Картинки/ФайлВар2.png)
* Вариант 3. Комбинациями клавиш
    * <kbd>CTRL</kbd>+<kbd>N</kbd>
    * <kbd>CTRL</kbd>+<kbd>ALT</kbd>+<kbd>WIN</kbd>+<kbd>N</kbd>  

    При таком способе создания файл надо сохранить через меню окна `Файл` или комбинацией <kbd>CTRL</kbd>+<kbd>S</kbd>

Теперь, когда файл создан, пора провести первый коммит. Сначала проверим, заметил ли [**Git**](#git) наш новый файл. Для этого в терминале введём команду `git status`. Если всё верно, вы увидите следующее:  
![Пример 1](Картинки/Пример1.png)  
Первые строки нас пока не интересуют, обратим внимание на строку `Untracked files`. Эта строчка указывает на файлы, которые **Git** видит, но не отслеживает, или отслеживаемые, но изменённые файлы *(их названия подсвечены красным)*  
> Необязательно писать назывние файла целиком. Достаточно первых четырёх символов, и автозаполнение, вызываемое клавишей <kbd>TAB</kbd> самостоятельно допишет название.  

Здесь же [**Git**](#git) нам подсказывает следующий шаг действий: необходимо ввести команду `git add <название файла>`, чтобы [проиндексировать](#index) *(подготовить к коммиту)* файл.  
Теперь, при вводе команды `git status` картина изменится:  
![Пример 2](Картинки/Пример2.png)  
`Untracked files` сменится на `Changes to be commited` и теперь показывает список [проиндексированных](#terms) *(готовых к коммиту)* файлов *(теперь их название подсвечены зелёным)*.  
Пора [коммитить](#terms) *(сохранять)* наш файл. Для этого введём команду `git commit -m "комментарий"`
> Во избежание проблем не следует забывать про часть `-m "комментарий"`. в ковычках нужно оставлять комментарий, описывающий произошедшие изменения. Для первого [коммита](#terms) обычно пишут `"Initial commit"`.

Успешный [коммит](#commit) отмечаем появившимся сообщением:  
![Пример 3](Картинки/Пример3.png)  
Обратим внимание на третью строку. В ней нам описывают произошедшие изменения *(1 файл изменён, 0 строк добавлено, 0 удалено)*. Добавление файла в [репозиторий](#rep) тоже считается его изменением, поэтому да, мы изменили *(добавили)* 1 файл, в котором не было ни добавлено, ни удалено ни одной строки *(т. к. он пустой)*.
## Работа с файлами
Теперь, когда мы [закоммители](#commit) наш первый файл, пора в нём что-нибудь записать и посмотреть как и на что это повлияет.
> Главное помнить, что после любого изменения файл нужно сохранять. Можно это сделать уже знакомой комбинацией <kbd>CTRL</kbd>+<kbd>S</kbd>, или, чтобы уж совсем голова об этом не болела можно включить **Автосохранение** через также знакомое на меню `Файл`.
### Изменения
Нашей основной командой для проверки произошедших изменений является уже знакомая `git status`. Мы уже видели реакцию этой команды на непроиндексированные и проиндексированные изменения, но это ещё не всё:  
![Пример 4](Картинки/Пример4.png)  
Такой вывод означает, что либо изменений не было, либо изменения были, но файл ещё не был сохранён.  
> Также командой `git status` обычно проверяют факт инициализации [репозитория](#rep) в [рабчей директории](#wd). Если инициализации не было, команда выдаст ошибку.

Второй командой, способной описать произошедшие изменения, является `git diff`. Она построчно сравнивает текущее состояние файла с его состоянием во время последнего [коммита](#commit) и показывает разницу.  
![Пример 5](Картинки/Пример5.png)  
Красным цветом показаны удалённые строки, а зелёным - добавленые
> Как можно заметить, для [**Git-a**](#git) любое изменение существующего - это удаление старого и добавление нового. Поэтому "Строка" появилась и среди удалённый, и среди добавленных.

При необходимости мы можем отменить введённые нами изменения. В зависимости от того, что нам нужно, можно использовать разные команды:
1. Если нужно удалить изменения из [индека](#index) используется команда `git reset`, чтобы отменить все изменения, или `git reset <Название файла>`, чтобы отменить изменения в одном конкретном файле. Сами изменения в файле останутся.
2. Если нужно удалить изменения полностью используются команды:
    * `git checkout <Название файла>` - возвращает состояние файла к моменту [индексации](#index).
    * `git reset --hard` - возвращает файл к состоянию на момент последнего коммита *(или коммита, на который указывает ())*, оставляет неотслеживаемое не тронутыми.
    * `git clean -df` - удаляет всё неотслеживаемое
### Коммиты
Чтобы [**Git**](#git) зафиксировал произошедшие изменения, нужно
1. [Проиндексировать](#index) эти изменения коммандой `git add`
    * Если нужно [Проиндексировать](#index) изменения только в одном файле, к команде нужно добавить название этого файла: `git add <Название файла>`
    * Если нужно [Проиндексировать](#index) все произошедшие изменения, включая добавления и удаления файлов, к команде добавляется точка или `--all`: `git add .`/`git add --all`
2. Провести [коммит](#commit) командой `git commit -m "комментарий"`
    * Если [Проиндексировать](#index) нужно только изменённый файлы, путь можно срезать составной командой `git commit -a -m "комментарий"` или `git commit -am "комментарий"`  
    > Такая команда называется составной, т. к. состоит из двух комманд: `git add` и, собственно, `git commit`. 

В процессе работы у нас будет накапливаться всё больше и больше [коммитов](#commit), и они не будут пропадать бесследно. Мы можем вызывать историю всех проведённых [коммитов](#commit) и, даже, перемещаться между ними.  
Для вызова истории [коммитов](#commit) используется команда `git log`. Выглядеть это будет так:  
![Пример 6](Картинки/Пример6.png)  
Список отображается в порядке от нового к старому. В нём мы можем видеть:
* Номер [коммита](#commit) *(Или, по другому, его **Хэш**)* выделенный жёлтым цветом. 
  > У первого в списке также можно увидеть указатель [**HEAD**](#head), который указывает, на каком [коммите](#commit) и на какой [ветке](#branch) мы сейчас находимся.
* Авторство коммита.
* Дата его проведения.
* Комментарий к этому коммиту.
> Если такое отображение кажется слишком гроиоздким, к команде можно добавить параметр `--oneline` *(`git log --oneline`)*  
![Пример 7](Картинки/Пример7.png)  
Теперь на один [коммит](#commit) выделяется одна строка: выводится сокращённый **хэш** и комментарий.

Узнав из лога **хэш** нужного нам [коммита](#commit), мы можем к нему переместиться. Для этого есть команда `git checkout <хэш>`.
> Не обязательно переносить **хэш** полностью. Достаточно первых четырёх символов.

> Если из такого состояния вызвать `git log`, мы увидим историю только до отображаемого сейчас [коммита](#commit). Чтобы увидеть весь список, нужно к команде добавить параметр `--all`: `git log --all`

Перенесясь на определённый [коммит](#commit) мы увидим, в каком состоянии был репозиторий на момент этого [коммита](#commit), будь то состояние файлов, их наличие или отсутствие. Здесь мы можем свободно экспериментировать не опасаясь что-либо сломать, т.к. на актуальный коммит эти эксперименты [коммит](#commit) не повлияют.  
> Чтобы всё-таки иметь возможность повлиять на актуальный [коммит](#commit) изменениями в прошлом, нужно создать новую [ветку](#branch), находясь на нужном нам [коммите](#commit). Как это сделать, будет расказано чуть позже.

Для возвращения к актуальному состоянию можно ввести несколько команд: 
* `git checkout master`/`git switch master` - по сути своей, переносят нас на [ветку](#branch) с названием **master** *(основная [ветка](#branch) по умолчанию. Может иметь другое имя, в зависимости от настроек)*
* `git checkout -`/`git switch -` - "шаг назад". Делает переход в обратном направлении, поэтому, если было совершено несколько коммитов, команда вернёт вас не на актуальный [коммит](#commit), а на тот, с которого был сделан переход.

В случае, если в комментарии к [коммиту](#commit) была совершена ошибка, его можно изменить, а, если сам [коммит](#commit) был совершён по ошибке, то этот[коммит](#commit) можно и вовсе удалить. Для этого используются следующте команды:
* `git commit -amend "Исправленый комментарий"` - исправлаяет комментарий в последнем [коммите](#commit).
  > Как уже упоминалось, для [**Git-a**](#git) нет изменений - только добавления и удаления. И данная команда не является исключением. Она удаляет старый [коммит](#commit), а после создаёт новый с новым комментарием и новым же **хэшем**.
* `git reset --параметр <хэш>` - уже знакомая нам команда. В зависимости от дополнительного параметра результат удаления будет разный:
    * `--hard` - сбросит всё до состояния указанного [коммита](#commit).
    * `--soft` - сбросит только [коммиты](#commit), [индекс](#index) и [директория](#wd) останутся нетронутыми.
    * без параметра - сбросит [коммиты](#commit) и [индекс](#index), [директория](#wd) останется нетронутой.
  > Вместо **хэша** можно указать `@~`, тогда команда будет сбрасывать до предыдущего [коммита](#commit). Если, нужно сбросить на несколько [коммитов](#commit), после `@~` указывается их количество *(`@~2` - сбросит на 2 [коммита](#commit) назад).*
## Указатели
В предыдущем разделе был упомянут указатель **HEAD**. Помимо него существуют и другие. В этом разделе будут даны их определления:
* <a id="head">**HEAD**</a> - указатель текущего местоположения.
* **ORIG_HEAD** -указатель изначального местоположения после использования команд перемещения. Видно при исползовании команды `git log --all`
* **Название [ветки](#branch)** - указывает на актуальный для данной [ветки](#branch) [коммит](#commit).
* **Теги** - проcтые создаваемые неперемещаемые указатели на [коммит](#commit). 
## Работа с ветками
Здесь будет расказано про ветки, которые вскользь упоминались в прошлых разделах.
<a id="branch">Ветка</a> - последовательность [коммитов](#commit), имеющая название. При инициализации [репозитория](#rep) также создаётся и первая ветка с названием **master**, и все последующие [коммиты](#commit) будут попадать в неё, пока не будет создана другая.  
Изменения в одной ветке не влияют на другие до момента их слияния. Поэтому их используют для параллельной, когда над одним проектом трудятся несколько человек и нужно избегать путаницы, или фрагментированной работы, когда в разных ветках пишутся отдельные части одного проекта.
> Уже сейчас можно посмотреть, какте ветки у нас есть с помощью команды `git branch`, правда, покажет нам наличие только одной ветки.    
![Пример 8](Картинки/Пример8.png)
### Создание и переходы
Для создания новой [ветки](#branch) можно воспользовоться разными способами и командами:
* Создать её с помощью команды `git branch <название новой ветки>`. Теперь, при использовании команды `git branch` нам покажет не только изначальную, но и только что созданную:  
![Пример 9](Картинки/Пример9.png)  
  > Звёздочкой возле названия и выделением зелёным цветом указывается наша текущая [ветка](#branch).

  Чтобы переместиться на созданную *(и, в принципе, любую)* [ветку](#branch) нужно востользоваться командой `git checkout <название ветки>` или `git switch <название ветки>`
  > После перемещения окажется, что в рабочей директории ничего не изменилось. Всё нормально, наша новая [ветка](#branch) ответвляется от [коммита](#commit), в котором была введена команда `git branch <название новой ветки>` *(в данном случае от последнего [коммита](#commit))*. Чтобы создать ветку из иного [коммита](#commit), нужно сначала на него переключиться.
* Создать и сразу перейти на созданную [ветку](#branch) командами `git checkout -b <название новой ветки>` или `git switch -c <название новой ветки>`.  
  > С этими командами также можно пропустить этап перехода на [коммит](#commit), от которого нужно отвести новую [ветку](#branch), если после названия создаваемой [ветки](#branch) ввести **хэш** этого [коммита](#commit) *(например, `git checkout -b new_branch  3196904` или `git switch -c new_branch  3196904`)*,  

> С созданием новых [веток](#branch) для команды `git log` становится актуальным параметр `--graph` *(`git log --graph`)*. С этим параметром нам будет показана история [коммитов](#commit) со всеми ответвлениями на другие ветки:  
![Пример 10](Картинки/Пример10.png)

> Также, стоит упомянуть, что в одной команде могут использоваться в несколько параметров. Так команда `git log --oneline --all --graph` покажет все [коммиты](#commit) всех [веток](#branch) в одну строку и в графическом виде *(порядок ввода параметров не важен. Например, команда `git log --all --oneline --graph` также сработает, сделав ровно то же самое)*:  
![Пример 11](Картинки/Пример11.png)
### Слияние, копирование и конфликты
### Синхронизация веток
### Удаление веток
## Работа с тегами
